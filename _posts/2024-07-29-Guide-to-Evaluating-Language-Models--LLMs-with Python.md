---
usemathjax: true
title: "Comprehensive Guide to Evaluating Language Models (LLMs) with Python"
excerpt: "Evaluating Language Models (LLMs) with Python"

header:
  image: "./../assets/images/posts/2024-07-29-Guide-to-Evaluating-Language-Models--LLMs-with Python/boitumelo-X89VSmdDKE0-unsplash.jpg"
  teaser: "./../assets/images/posts/2024-07-29-Guide-to-Evaluating-Language-Models--LLMs-with Python/boitumelo-X89VSmdDKE0-unsplash.jpg"
  caption: "When deploying AI, whether you focus on top-line growth or bottom-line profitability, start with the customer and work backward - Rob Garf , Photo by Boitumelo"
  
---

## Introduction

Evaluating the performance of Large Language Models (LLMs) is crucial for ensuring they meet expectations in terms of accuracy, logical reasoning, ethical behavior, and usability. In real-world applications, LLMs must not only provide accurate answers but also avoid hallucinations, maintain logical consistency, and adhere to ethical standards.

Why is this important?  

- **Reliability**: Ensures models behave predictably across scenarios.  
- **Benchmarking**: Helps compare models objectively, aiding deployment decisions.  
- **Improvement**: Highlights areas needing refinement, such as hallucinations or logical errors.  
- **Ethical Safety**: Ensures the model avoids harmful or biased behavior.

This blog starts from the basics and dives deep into evaluation metrics, explaining their use cases, formulas, and Python implementations. By the end, you'll know how to evaluate LLMs comprehensively and write your own benchmarks and research papers.

---

## Key Metrics Overview

| **Metric**                             | **Purpose**                                        | **Formula/Method**                                           | **Use Case**                |
| -------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ | --------------------------- |
| **Hallucination Reduction Rate (HRR)** | Measures reduction in factual hallucinations.      | $$ \frac{\text{Reduced Hallucinations}}{\text{Baseline Hallucinations}} \times 100 $$ | Fact-checking LLM outputs.  |
| **Logical Consistency Score (LCS)**    | Evaluates logical adherence.                       | $$ \frac{\text{Consistent Responses}}{\text{Total Responses}} \times 100 $$ | Logical problem-solving.    |
| **Response Accuracy (RA)**             | Measures response correctness.                     | $$ \frac{\text{Correct Responses}}{\text{Total Queries}} \times 100 $$ | General Q&A systems.        |
| **Exact Match (EM)**                   | Measures complete correctness.                     | Match Prediction and Target                                  | Closed Q&A systems.         |
| **F1 Score**                           | Balances precision and recall.                     | $$ \frac{2 \times (P \times R)}{P + R} $$                    | Classification tasks.       |
| **ROUGE**                              | Measures overlap in generated and reference texts. | Token Overlap Ratios                                         | Summarization tasks.        |
| **BLEU**                               | Evaluates translation accuracy.                    | N-gram Overlap Ratios                                        | Machine translation.        |
| **Toxicity Detection**                 | Detects harmful outputs.                           | Detoxify Framework                                           | Content moderation.         |
| **Perplexity**                         | Measures fluency and confidence.                   | $$-\frac{1}{n} \sum_{i=1}^n \log(P(x_i))$$                   | Evaluates language fluency. |

---

## Setting Up the Environment

Before diving into the code, ensure the necessary Python libraries are installed:

```bash
pip install numpy pandas scikit-learn rouge-score nltk detoxify lm-eval matplotlib
```

and for cuda 11.8

```
pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
```

More information visit the page of [torch](https://pytorch.org/get-started/locally/).

---

## Metrics and Detailed Implementations

---

### 1. **Hallucination Reduction Rate (HRR)**

Hallucinations are factual inaccuracies generated by LLMs. For example, if a model claims, "Albert Einstein discovered penicillin," it's fabricating information. The **Hallucination Reduction Rate** measures how effectively a model eliminates these errors after fine-tuning or validation.

**Formula**:
$$
HRR = \frac{\text{Number of hallucinations reduced}}{\text{Total hallucinations in baseline}} \times 100
$$

**Python Implementation**:

```python
def calculate_hrr(baseline_outputs, validated_outputs):
    hallucinations_reduced = sum(
        1 for base, valid in zip(baseline_outputs, validated_outputs)
        if base.get("is_hallucination") and not valid.get("is_hallucination")
    )
    total_hallucinations = sum(1 for base in baseline_outputs if base.get("is_hallucination"))
    return (hallucinations_reduced / total_hallucinations) * 100 if total_hallucinations > 0 else 0

# Example Data
baseline_outputs = [
    {"query": "What is the boiling point of water?", "output": "50°C", "is_hallucination": True},
    {"query": "Who wrote Hamlet?", "output": "Charles Dickens", "is_hallucination": True}
]
validated_outputs = [
    {"query": "What is the boiling point of water?", "output": "100°C", "is_hallucination": False},
    {"query": "Who wrote Hamlet?", "output": "William Shakespeare", "is_hallucination": False}
]

# Calculate HRR
hrr_score = calculate_hrr(baseline_outputs, validated_outputs)
print(f"Hallucination Reduction Rate (HRR): {hrr_score:.2f}%")
```

**Result**:  
If the validated model eliminates all hallucinations, the HRR will be **100%**. A lower HRR indicates persistent inaccuracies.


**Explanation**  
Hallucinations are incorrect or fabricated facts generated by LLMs. For example:

- **Hallucination**: "Albert Einstein discovered penicillin."
- **Correct Output**: "Alexander Fleming discovered penicillin."

##### When HRR is Low

- **Case 1**: Persistent Hallucinations  
  The model continues to hallucinate similar errors, such as confidently stating incorrect historical facts.
- **Case 2**: Partial Correction  
  The hallucination changes but remains incorrect, e.g., “Albert Einstein co-discovered penicillin with Alexander Fleming.”

These cases indicate the need for further fine-tuning or dataset refinement.

---

### 2. **Logical Consistency Score (LCS)**


Logical consistency evaluates the model's ability to reason correctly. Consider these examples:

- **Consistent**:  
  - Premise: "If A > B and B > C, then A > C."
  - Model Output: "True."
- **Inconsistent**:  
  - Premise: "All squares have four sides. A triangle is a square." *(Incorrect premise)*


**Formula**:
$$
LCS = \frac{\text{Number of logically consistent responses}}{\text{Total responses}} \times 100
$$

**Python Implementation**:

```python
def calculate_lcs(responses):
    consistent_responses = sum(1 for response in responses if response.get("is_consistent"))
    return (consistent_responses / len(responses)) * 100

# Example Data
responses = [
    {"query": "If A > B and B > C, is A > C?", "output": "Yes", "is_consistent": True},
    {"query": "Can a square have three sides?", "output": "No", "is_consistent": True}
]

# Calculate LCS
lcs_score = calculate_lcs(responses)
print(f"Logical Consistency Score (LCS): {lcs_score:.2f}%")
```

**Result**:  
A high LCS indicates the model maintains logical coherence across its responses.

---

### 3. **Response Accuracy (RA)**

**Response Accuracy** evaluates whether the model's answers are factually correct. 

RA focuses on the factual correctness of outputs. 
RA becomes crucial in high-stakes applications, such as medical or legal decision-making, where inaccuracies can lead to serious consequences.


For instance:

- **Correct**: "What is 2 + 2?" → "4"
- **Incorrect**: "Who wrote Macbeth?" → "Charles Dickens"

**Formula**:
$$
RA = \frac{\text{Number of correct responses}}{\text{Total queries}} \times 100
$$

**Python Implementation**:

```python
def calculate_ra(gold_standard, model_outputs):
    correct_responses = sum(
        1 for gold, output in zip(gold_standard, model_outputs)
        if gold["correct_answer"] == output["output"]
    )
    return (correct_responses / len(gold_standard)) * 100

# Example Data
gold_standard = [
    {"query": "What is 2 + 2?", "correct_answer": "4"},
    {"query": "Who wrote Macbeth?", "correct_answer": "William Shakespeare"}
]
model_outputs = [
    {"query": "What is 2 + 2?", "output": "4"},
    {"query": "Who wrote Macbeth?", "output": "Charles Dickens"}
]

# Calculate RA
ra_score = calculate_ra(gold_standard, model_outputs)
print(f"Response Accuracy (RA): {ra_score:.2f}%")
```

**Result**:  
A higher RA reflects more accurate and reliable responses.



### 4. **Exact Match (EM)**

Exact Match is a strict metric that checks whether the model's prediction matches the reference answer exactly. This is especially useful in tasks like multiple-choice questions or structured information extraction.

**Formula**:  
$$
EM = \text{Exact match between prediction and target}
$$

**Python Implementation**:

```python
def exact_match(prediction, target):
    return prediction == target

# Example Data
prediction = "Paris"
target = "Paris"

# Calculate EM
em_score = exact_match(prediction, target)
print(f"Exact Match (EM): {em_score}")
```

**Result**:  
If the prediction matches the target exactly, **True** is returned; otherwise, **False**.

**Example Output**:

```
Exact Match (EM): True
```

**Explanation**:  
Exact Match is strict and binary. It’s particularly useful for tasks where the response format is rigid.

---

### 5. **F1 Score**

F1 balances precision (relevance of outputs) and recall (coverage of correct outputs). For example:

- **High Precision, Low Recall**: Retrieves relevant answers but misses many correct ones.
- **High Recall, Low Precision**: Retrieves all correct answers but includes irrelevant ones.



**Formula**:  
$$
F1 = \frac{2 \times (\text{Precision} \times \text{Recall})}{\text{Precision} + \text{Recall}}
$$

**Python Implementation**:

```python
from sklearn.metrics import f1_score

def calculate_f1(predictions, targets):
    return f1_score(targets, predictions, average="binary")

# Example Data
predictions = [1, 0, 1, 1]
targets = [1, 0, 0, 1]

# Calculate F1 Score
f1 = calculate_f1(predictions, targets)
print(f"F1 Score: {f1:.2f}")
```

**Result**:  
The F1 Score ranges from 0 (worst) to 1 (best).

**Example Output**:

```
F1 Score: 0.80
```

**Explanation**:  
A high F1 Score indicates a balance between precision and recall, minimizing false positives and false negatives.

---

### 6. **ROUGE**

ROUGE measures the overlap between generated and reference texts. It’s widely used in summarization tasks.
 For example:

- Reference: "The quick brown fox jumps over the lazy dog."
- Prediction: "The fox quickly jumped over a lazy dog."

**Metrics**:

- **ROUGE-1**: Overlap of unigrams (single words).
- **ROUGE-L**: Longest common subsequence.

**Python Implementation**:

```python
from rouge_score import rouge_scorer

def calculate_rouge(prediction, target):
    scorer = rouge_scorer.RougeScorer(['rouge1', 'rougeL'], use_stemmer=True)
    return scorer.score(target, prediction)

# Example Data
prediction = "The cat sat on the mat."
target = "The cat is on the mat."

# Calculate ROUGE
rouge_scores = calculate_rouge(prediction, target)
print("ROUGE Scores:", rouge_scores)
```

**Result**:  
ROUGE provides scores for precision, recall, and F1 for each metric.

**Example Output**:

```
ROUGE Scores: {'rouge1': ..., 'rougeL': ...}
```

**Explanation**:  
A high ROUGE score indicates a close match between the generated and reference texts.

---

### 7. **BLEU**

BLEU measures the n-gram overlap between the generated text and the reference text. It’s commonly used in machine translation.
BLEU focuses on n-gram overlap. For example:

- Reference: "The cat is on the mat."
- Prediction: "A cat is on the rug."


**Formula**:  
BLEU considers precision over n-grams, with optional smoothing to handle zero matches.

**Python Implementation**:

```python
from nltk.translate.bleu_score import sentence_bleu, SmoothingFunction

def calculate_bleu(prediction, target):
    reference = [target.split()]
    candidate = prediction.split()
    smoothing_function = SmoothingFunction().method1
    return sentence_bleu(reference, candidate, smoothing_function=smoothing_function)

# Example Data
prediction = "The cat is on the mat."
target = "The cat sat on the mat."

# Calculate BLEU
bleu_score = calculate_bleu(prediction, target)
print(f"BLEU Score: {bleu_score:.2f}")
```

**Result**:  
The BLEU score ranges from 0 (no overlap) to 1 (perfect match).

**Example Output**:

```
BLEU Score: 0.25
```

**Explanation**:  
A higher BLEU score indicates better translation or text generation quality.

---

### 8. **Toxicity Detection**

Toxicity Detection ensures that the LLM generates safe and respectful language, avoiding harmful content.

This metric ensures that the LLM generates safe and respectful language. Example:

- **Toxic**: "You're an idiot."
- **Non-Toxic**: "I disagree with your opinion."


**Python Implementation**:

```python
from detoxify import Detoxify

def detect_toxicity(text):
    model = Detoxify('original')
    return model.predict(text)

# Example Data
texts = [
    "This is a respectful comment.",
    "This is a hateful comment."
]

# Detect Toxicity
for text in texts:
    print(f"Toxicity for '{text}': {detect_toxicity(text)}")
```

**Result**:  
Scores indicate the likelihood of toxicity in each text.

**Example Output**:

```
Toxicity for 'This is a respectful comment.': ...
Toxicity for 'This is a hateful comment.': ...
```

**Explanation**:  
Lower toxicity scores are better, indicating safer outputs.

```python
# Detect Toxicity
for text in texts:
    print(f"Toxicity for '{text}':")
    results = detect_toxicity(text)
    for key, value in results.items():
        print(f"  {key.replace('_', ' ').title()}: {value:.4f}")
```

```bash
Toxicity for 'This is a respectful comment.':
  Toxicity: 0.0006
  Severe Toxicity: 0.0001
  Obscene: 0.0002
  Threat: 0.0001
  Insult: 0.0002
  Identity Attack: 0.0001
Toxicity for 'This is a hateful comment.':
  Toxicity: 0.1266
  Severe Toxicity: 0.0002
  Obscene: 0.0021
  Threat: 0.0005
  Insult: 0.0020
  Identity Attack: 0.0007
```

### 9. **Perplexity**

Lower perplexity indicates more fluent and confident text generation. However, low perplexity doesn’t guarantee factual correctness.

Perplexity measures the fluency of the generated text. Lower perplexity indicates the model is more confident in its predictions.

**Formula**:  
$$
\text{Perplexity} = e^{-\frac{1}{N} \sum_{i=1}^{N} \log P(x_i)}
$$

**Python Implementation**:

```python
from lm_eval.evaluator import simple_evaluate

# Run Perplexity Evaluation
try:
    results = simple_evaluate(
        model="hf",  # Use Hugging Face AutoModel
        model_args="pretrained=gpt2",  # Specify the pretrained model
        tasks=["lambada_openai"],  # Evaluate on a benchmark task
    )
    print("Perplexity Results:", results)
except ImportError as e:
    print("Please install the `lm-eval` library.")
```

**Result**:  
Lower perplexity scores reflect more fluent and confident predictions.

**Example Output**:

```
Perplexity Results: ...
```

**Explanation**:  
While perplexity reflects fluency, it doesn’t guarantee factual correctness.


#### 10. **Diversity Score**

**Formula**:
$$
\text{Diversity} = \frac{\text{Unique N-grams}}{\text{Total N-grams}}
$$

**Extended Explanation**  
The diversity score measures the variety in generated text, ensuring the model avoids repetitive patterns. It is particularly useful for creative writing tasks, such as story generation or poetry, where repetition can degrade quality.

**Python Implementation**:

```python
from collections import Counter

def calculate_diversity(text, n=2):
    words = text.split()
    ngrams = [' '.join(words[i:i+n]) for i in range(len(words)-n+1)]
    total_ngrams = len(ngrams)
    unique_ngrams = len(set(ngrams))
    return unique_ngrams / total_ngrams if total_ngrams > 0 else 0

# Example Data
text = "The quick brown fox jumps over the lazy dog. The quick brown fox repeats."
diversity_score = calculate_diversity(text, n=2)
print(f"Diversity Score (2-grams): {diversity_score:.2f}")
```

**Example Output**:

```
Diversity Score (2-grams): 0.77
```

**Explanation**:  
A higher diversity score reflects less repetition in the generated text.

---

#### 11. **Coherence Score**

**Formula**:
$$
\text{Coherence} = \text{Semantic similarity with context}
$$


The coherence score evaluates how well a generated response aligns with the preceding context in a conversation or multi-turn dialogue. It ensures that the response is both relevant and logically connected to the input.

**Python Implementation**:

```python
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

def calculate_coherence(context, response):
    vectorizer = TfidfVectorizer().fit([context, response])
    vectors = vectorizer.transform([context, response])
    return cosine_similarity(vectors[0], vectors[1])[0][0]

# Example Data
context = "What is the capital of France?"
response = "Paris is the capital of France."
coherence_score = calculate_coherence(context, response)
print(f"Coherence Score: {coherence_score:.2f}")
```

**Example Output**:

```
Coherence Score: 0.95
```

**Explanation**:  
A high coherence score indicates that the response is contextually and semantically relevant to the input.

---

#### 12. **Bias Detection**

**Extended Explanation**  
Bias detection ensures that the model avoids generating prejudiced or unfair content. This metric helps identify and mitigate harmful stereotypes or discriminatory outputs.

**Python Implementation**:

```python
from detoxify import Detoxify

def detect_bias(text):
    model = Detoxify('original')
    predictions = model.predict(text)
    return predictions['toxicity'], predictions['insult']

# Example Data
biased_text = "Men are better leaders than women."
toxicity, insult = detect_bias(biased_text)
print(f"Toxicity Score: {toxicity:.2f}, Insult Score: {insult:.2f}")
```

**Example Output**:

```
Toxicity Score: 0.65, Insult Score: 0.50
```

**Explanation**:  
Lower scores are desirable, indicating minimal bias or harmful content in the text.

---

#### 13. **Knowledge Retention**

**Extended Explanation**  
Knowledge retention measures the ability of a model to recall factual information over time. This metric is crucial for evaluating whether fine-tuning or retraining has degraded the model's understanding of previously learned knowledge.

**Python Implementation**:

```python
def evaluate_knowledge_retention(questions, correct_answers, model_outputs):
    retained = sum(1 for q, a, o in zip(questions, correct_answers, model_outputs) if a == o)
    return retained / len(questions) * 100

# Example Data
questions = ["Who wrote Hamlet?", "What is the capital of Italy?"]
correct_answers = ["William Shakespeare", "Rome"]
model_outputs = ["William Shakespeare", "Rome"]  # Outputs from the model
knowledge_retention_score = evaluate_knowledge_retention(questions, correct_answers, model_outputs)
print(f"Knowledge Retention Score: {knowledge_retention_score:.2f}%")
```

**Example Output**:

```
Knowledge Retention Score: 100.00%
```

**Explanation**:  
A high score indicates that the model retains its knowledge base effectively without significant degradation.

### Conclusion

This comprehensive guide covers the most important metrics for evaluating LLMs, including explanations, formulas, and Python implementations. By mastering these metrics, you can:

- Benchmark different models.
- Improve performance through targeted fine-tuning.
- Write research papers showcasing your evaluation results.

You can download this notebook [here](https://github.com/ruslanmv/Comprehensive-Guide-to-Evaluating-LLMS-with-Python/blob/master/notebook.ipynb)

**Congratulations!**

Start using these metrics today to evaluate your own LLMs and contribute to the development of better AI systems! 





